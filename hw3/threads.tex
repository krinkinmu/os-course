\section{Функции управления потоками}

От функций управления потоками ожидается как минимум следующая функциональность:
\begin{itemize}
  \item создание потока и выделение всех необходимых ему ресурсов;
  \item завершение потока и освобождение его ресурсов;
  \item ожидание завершения некоторого потока;
\end{itemize}

\subsection{Создание потока исполнения}

Поток исполнения должен исполнять какой-то код, поэтому разумно, что в функцию
создания потока исполнения будет передан указатель на функцию, с которой
начнется исполнение потока - этакий main. Опционально\footnote{И это довольно
полезно.} можно предусмотреть передачу некоторого параметра функции, которую
будет исполнять поток.

Кроме того, так как потоков может быть несколько, полезно иметь возможность
обращаться к потокам исполнения, т. е. иметь некоторый идентификатор потока
исполнения, по которому его можно найти.

Таким образом функция создания потока может иметь примерно такую сигнатуру:

\begin{verbatim}
pid_t create_thread(void (*fptr)(void *), void *arg);
\end{verbatim}

где
\begin{itemize}
  \item pid\_t - идентификатор созданного потока, или например, код ошибки, если
        не удалось создать поток
  \item fptr - главная функция потока (его main)
  \item arg - аргумент, который будет передан в fptr, когда поток начнет свое
        исполнение.
\end{itemize}

С каждым потоком исполнения связан набор ресурсов, например, поток исполнения
может иметь свою таблицу страниц\footnote{Что в нашем случае не обязательно, и
все потоки могут пользоваться общей таблицей страниц, или использовать свою
таблицу, в которой есть отображение для общей памяти всех потоков.}, или
некоторый дексриптор\footnote{Структура, которая описывает состояние потока, его
ресурсы и прочее.}. Набор ресурсов зависит от фантазии разработчика, но каждый
поток исполнения обязан иметь свой собственный стек. Таким образом функция
создания потока как минимум должна выделить для него стек.

Но самая содержательная часть этой функции заключается в том, что она должна
инициализировать ресурсы потока таким образом, чтобы ему можно было передать
управление, т. е. чтобы планировщик мог переключиться с другого потока на поток
созданный этой функцией. Как именно этого добится, естественно, зависит от того,
как ваш планировщик переключает потоки.

Пример реализации переключения потоков вы можете найти в лекции, напомню, что
для сохранения состояния потока используется стек этого потока. И, когда
планировщик переключается на новый поток, он "восстанавливает" его состояние со
стека. Но что если это совсем новый поток, который еще никогда не выполнялся?
Планировщик, еще не снимал его с процессора и значит не сохранял его состояние
на стек. Соответственно функция создания потока должна инициализировать стек
потока таким образом, чтобы планировщик смог "восстановить" из него состояние
вновь созданного потока.

\subsection{Завершение потока исполнения и ожидание завершения}

Потоки не работают бесконечно, поэтому вы должны предоставить функцию для
завершения потока (аналог функции exit). Процессор, однако, ничего не знает
о потоках - это абстракция нашей ОС, он просто исполняет инструкции. Отсюда
следует, что когда поток завершается, на его место должен встать кто-то другой.
Пожтому завершение потока предполагает, что произойдет переключение на какой-то
другой поток исполнения, а ваша обязанность гарантировать, что такой поток
исполнения всегда будет. Другими словами сложность этой части задания в том,
что вы должны создать специальный поток, который выполняется, когда больше
некому выполняться\footnote{Такой поток обычно называют idle.}.

Другая сложность связанная с завершением потоков заключается в том, что после
завершения потока необзодимо освободить ресурсы, которые он занимает (как
минимум стек). Более того, сделать это непосредственно в функции завершения
потока нельзя\footnote{Почему?}. Самый очевидный вариант - поручить освобождение
ресурсов потока тому, кто занял его место, т. е. следующему потоку на
процессоре.

Наконец, если поток может завершиться, значит кто-то может ждать, пока он
завершится. Вам нужно предусмотреть возможность подождать завершения
определенного потока\footnote{Семантика схожая с pthread\_join.}.
